from _util import writeFile, readFileLines
from _elements import makeElements
from os import path
from pprint import pformat
from importlib import import_module
import logging

CACHE_DIR = '_cache'
NNDB_DIR = 'nndb'
NNDB_DELIM = '^'
CHUNK_SIZE = 50
CHUNKS_FILE = 'chunks'

NNDB_STRUCT = {
    'DATA_SRC': ['DataSrc_ID', 'Authors', 'Title', 'Year', 'Journal',
                 'Vol_City', 'Issue_State', 'Start_Page', 'End_Page'],
    'DATSRCLN': ['NDB_No', 'Nutr_No', 'DataSrc_ID'],
    'DERIV_CD': ['Deriv_Cd', 'Deriv_Desc'],
    'FD_GROUP': ['FdGrp_Cd', 'FdGrp_Desc'],
    'FOOTNOTE': ['NDB_No', 'Footnt_No', 'Footnt_Typ', 'Nutr_No', 'Footnt_Txt'],
    'FOOD_DES': ['NDB_No', 'FdGrp_Cd', 'Long_Desc', 'Shrt_Desc', 'ComName',
                 'ManufacName', 'Survey', 'Ref_desc', 'Refuse', 'SciName',
                 'N_Factor', 'Pro_Factor', 'Fat_Factor', 'CHO_Factor'],
    'LANGDESC': ['Factor_Code', 'Description'],
    'LANGUAL': ['NDB_No', 'Factor_Code'],
    'NUT_DATA': ['NDB_No', 'Nutr_No', 'Nutr_Val', 'Num_Data_Pts', 'Std_Error',
                 'Src_Cd', 'Deriv_Cd', 'Ref_NDB_No', 'Add_Nutr_Mark',
                 'Num_Studies', 'Min', 'Max', 'DF', 'Low_EB', 'Up_EB',
                 'Stat_cmt', 'AddMod_Date', 'CC'],
    'NUTR_DEF': ['Nutr_No', 'Units', 'Tagname', 'NutrDesc', 'Num_Dec',
                 'SR_Order'],
    'SRC_CD': ['Src_Cd', 'SrcCd_Desc'],
    'WEIGHT': ['NDB_No', 'Seq', 'Amount', 'Msre_Desc', 'Gm_Wgt', 'Num_Data_Pts',
               'Std_Dev']
}

ELEMENTS_MAP = {
    'ENERC_KCAL': ('energy', 'kcal'),
    'WATER': ('water', 'g'),
    'Protein': ('protein', 'g'),
    'Total lipid (fat)': ('fat', 'g'),
    'Fatty acids, total saturated': ('fatSat', 'g'),
    'Carbohydrate, by difference': ('carb', 'g'),
    'Sugars, total': ('sugar', 'g'),
    'Sodium, Na': ('sodium', 'mg'),
    'Cholesterol': ('chol', 'mg'),
    'Fiber, total dietary': ('fiber', 'g'),
    'Potassium, K': ('potassium', 'mg'),
    'Iron, Fe': ('iron', 'mg'),
    'Calcium, Ca': ('calcium', 'mg'),
    'Vitamin A, RAE': ('vitaminA', 'RAE', u'\xb5g'),
    'Retinol': ('retinol', 'mcg', u'\xb5g'),
    'Vitamin C, total ascorbic acid': ('vitaminC', 'mg'),
    'Vitamin D': ('vitaminD', 'IU_vitaminD', 'IU'),
    'Vitamin E (alpha-tocopherol)': ('vitaminE', 'mg'),
    'Vitamin E, added': ('vitaminESup', 'mg'),
    'Vitamin K (phylloquinone)': ('vitaminK', 'mcg', u'\xb5g'),
    'Thiamin': ('thiamin', 'mg'),
    'Riboflavin': ('riboflavin', 'mg'),
    'Niacin': ('niacin', 'mg'),
    # no data for niacinSup
    'Vitamin B-6': ('vitaminB6', 'mg'),
    'Folate, DFE': ('folate', 'DFE', u'\xb5g'),
    'Folic acid': ('folateSup', 'mcg_folicAcid', u'\xb5g'),
    'Vitamin B-12': ('vitaminB12', 'mcg', u'\xb5g'),
    'Pantothenic acid': ('pantothenicAcid', 'mg'),
    # no data on biotin
    'Choline, total': ('choline', 'mg'),
    # no data on chromium
    'Copper, Cu': ('copper', 'mg'),
    'Fluoride, F': ('fluoride', 'mcg', u'\xb5g'),
    # no data on iodine
    'Magnesium, Mg': ('magnesium', 'mg'),
    # no data on magnesiumSup
    'Manganese, Mn': ('manganese', 'mg'),
    # no data on molybdenum
    'Phosphorus, P': ('phosphorus', 'mg'),
    'Selenium, Se': ('selenium', 'mcg', u'\xb5g'),
    'Zinc, Zn': ('zinc', 'mg')
    # no data on chloride
    # no data on boron
    # no data on nickel
    # no data on silicon
    # no data on vanadium
}

def chunkFileName(name):
    return path.join(path.dirname(__file__), CACHE_DIR, '%s.py' % name)
    
def rebuildCache():
    logging.info('Rebuilding nutrition data cache...')
    nndb = dict([(k, loadNNDBTable(k, v))
                 for k, v in NNDB_STRUCT.items()])
    logging.info('Building lookup tables...')
    lookup = {}
    for name, rows in nndb.items():
        logging.debug('NNDB table %s has %i rows' % (name, len(rows)))
        lookup[name] = {}
        for row in rows:
            k = row[0]
            if k not in lookup[name]:
                lookup[name][k] = []
            lookup[name][k].append(dict(zip(NNDB_STRUCT[name], row)))
    logging.info('Populating cache...')
    allCodes = sorted(lookup['FOOD_DES'].keys())
    chunkNos = dict([(allCodes[i], i // CHUNK_SIZE)
                     for i in xrange(len(allCodes))])
    writeFile(chunkFileName(CHUNKS_FILE), '\n'.join([
        '# autogenerated',
        '',
        'chunkNos = \\',
        pformat(chunkNos),
        ''
    ]))
    totalChunks = (len(allCodes) // CHUNK_SIZE) + 1
    for chunkNo in xrange(totalChunks):
        logging.info('Building cache chunk %i of %i' % (chunkNo+1, totalChunks))
        chunk = {}
        for code in allCodes[chunkNo * CHUNK_SIZE : (chunkNo+1) * CHUNK_SIZE]:
            chunk[code] = {
                'name': makeName(code, lookup),
                'dataUrl': makeDataUrl(code),
                'refusePercent': makeRefusePercent(code, lookup),
                'refuseDesc': makeRefuseDesc(code, lookup),
                'elementsMass': (100.0, 'g'),
                'elements': makeElements(**extractElements(code, lookup))
            }
        fname = path.join(chunkFileName(chunkName(chunkNo)))
        writeFile(fname, '\n'.join([
            '# autogenerated',
            '',
            'values = \\',
            pformat(chunk),
            ''
        ]))

def makeRefusePercent(code, lookup):
    food = lookup['FOOD_DES'][code][0]
    ref = food['Refuse']
    return float(ref) if ref else 0.0

def makeRefuseDesc(code, lookup):
    food = lookup['FOOD_DES'][code][0]
    return food['Ref_desc']

def extractElements(code, lookup):
    res = {}
    for nut in lookup['NUT_DATA'][code]:
        nutDef = lookup['NUTR_DEF'][nut['Nutr_No']][0]
        nutDesc = nutDef['NutrDesc']
        nutTag = nutDef['Tagname']
        if nutDesc in ELEMENTS_MAP:
            elemInfo = ELEMENTS_MAP[nutDesc]
        elif nutTag in ELEMENTS_MAP:
            elemInfo = ELEMENTS_MAP[nutTag]
        else:
            continue
        elemName, elemUnit = elemInfo[:2]
        elemUnitOrig = elemUnit if len(elemInfo) == 2 else elemInfo[2]
        nutUnit = nutDef['Units']
        if nutUnit != elemUnitOrig:
            raise Exception('Units mismatch for code %s, element %s: '
                            'expected "%s", actual "%s"'
                            % (code, elemName, elemUnitOrig, nutUnit))
        nutVal = nut['Nutr_Val']
        try:
            res[elemName] = (float(nutVal), elemUnit)
        except ValueError:
            raise Exception('Invalid value "%s" for code %s element %s'
                            % (nutVal, code, elemName))
    return res

def makeDataUrl(code):
    return 'http://ndb.nal.usda.gov/ndb/search/list?qlookup=%s' % code

def makeName(code, lookup):
    return lookup['FOOD_DES'][code][0]['Long_Desc']

def chunkName(chunkNo):
    return 'chunk%i' % chunkNo

def loadNNDBTable(name, cols):
    fname = path.join(path.dirname(__file__), NNDB_DIR, '%s.txt' % name)
    logging.info('Loading NNDB table from file "%s"...' % fname)
    return parseNNDBTable(readFileLines(fname), cols)

def parseNNDBTable(rows, cols):
    actCols = len(rows[0].split(NNDB_DELIM))
    if len(cols) != actCols:
        raise Exception('Columns mismatch: declared %i, actual %i'
                        % (len(cols), actCols))
    dequote = lambda x: x[1:-1] if x.startswith('~') and x.endswith('~') else x
    process = lambda x: dequote(x.decode('latin1').strip())
    return [[process(x) for x in row.split(NNDB_DELIM)] for row in rows]

def fetchNndb(code):
    import _cache
    import _cache.chunks
    assert type(code) in (str, unicode)
    chunkNo = _cache.chunks.chunkNos[code]
    name = chunkName(chunkNo)
    if not hasattr(_cache, name):
        logging.debug('Loading cache chunk %i' % chunkNo)
        import_module('.%s.%s' % (CACHE_DIR, name), package='diethack')
    return getattr(_cache, name).values[code]

def fetchNndbCodes():
    import _cache.chunks
    return _cache.chunks.chunkNos.keys()
